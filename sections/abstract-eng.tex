\section*{Abstract}

Programs in domains such as robotics, the web and mobile applications are all driven by streams of events. This inherently asynchronous model mismatches with the synchronous nature of imperative, sequential programming, which is why other paradigms have cropped up over time to better address these concerns. One such paradigm designed to thrive in event driven environments is reactive programming, which reifies events as time varying values and makes them composable using declarative operators. It tries to address the challenges of asynchronous programming, such as the aptly named \textit{callback hell}, by providing a unified interface over various sources of asynchrony (e.g. I/O, events, etc.) and thereby streamlining how data is passed on through these programs.

With this high level of abstraction however comes a concern for efficiency and timing, which is of the utmost importance for these systems. The majority of reactive programs so far are single threaded and don't leverage the full potential of their underlying hosts.  Research has already been done on parallelising these programs, but we propose another alternative: mapping them onto the dataflow execution model. This low level execution platform specifies that primitive instructions can be invoked whenever their inputs are present, provided that these instructions do not access or mutate shared state. This allows unrelated instructions, i.e. which do not share any data dependencies, to be completely run in parallel.

In this paper, we describe the process of mapping reactive time varying values to instructions in the dataflow execution model. We present two interpreters for a small experimental language designed for the purposes of this dissertation; one which implements reactivity in a traditional sense and one which runs atop a dataflow engine. 
A summary of the mismatch between the two models is presented, and the solutions provided for these mismatches are discussed. 

Finally, we evaluate the performance characteristics of both approaches in terms of efficiency for multiple types of programs and discuss the scalability of reactive programs atop a dataflow engine.
            